## 一、

### 1.常见跨域方式

​	jsonp原理：利用script标签没有同源策略的原理来实现跨域。

​	前端需要通过**query传递回调函数**给后台，后台需要将**回调函数与数据**进行拼接，传递给前台 。前台在运行这一段js代码。

```
//前端
<script>
function w124358539(data){
	cosole.log(data)
}
</script>
<<script src="http://www.xxx.com/jsonp.php?a=1&b=2&cb=w124358539">

```

```
//服务器
<?php
header('Content-type: application/json');
//获取回调函数名
$jsoncallback = htmlspecialchars($_REQUEST ['cb']);
//json数据
$json_data = '["htmlspecialchars($_REQUEST ['a'])","htmlspecialchars($_REQUEST ['b'])"]';
//输出jsonp格式的数据
echo $jsoncallback . "(" . $json_data . ")";
?>

```

### 2.

​	cors原理：同源策略告诉浏览器阻止跨源请求。当你想从不同的源获取公共资源时，资源提供服务器需要告诉浏览器“请求来自的这个源可以访问我的资源”。浏览器记住这一点并允许跨源资源共享。

​	为什么会有cors：由于浏览器的同源策略，导致了跨域请求资源的不便。

​	后台需要在响应头中添加：

```
access-control-allow-origin：*     //被允许请求的url
```

​	如果要带请求要cookie：

​	对于前端：对于跨域的 `XMLHttpRequest` 请求，需要设置`withCredentials` 属性为 true。

​	同时服务端的响应中必须携带 `Access-Control-Allow-Credentials: true`。



## 二、https：

HTTPS的大致加密流程是怎样的？有什么常用的加密算法？

​	流程：

​	(1) 客户端向服务端发送自己支持的SSL协议版本，支持的加密算法，和一个随机生成的随机数1。

​	(2) 服务端向客户端发送选择的SSL协议版本、加密算法，和一个随机生成的随机数2。

​	(3) 服务端向客户端发送自己的证书。（证书是由CA机构的私钥加密服务端的公钥得到的） 。

​	(4) 客户端用CA机构的公钥解密得到服务端额公钥，并验证证书。

​	(5) 客户端将前两次传输的随机数用一种hash算法计算的到xx传给服务端，并随机生成一个随机数3发送给服务端。

​	(6) 服务端采用同样的hash算法计算随机数1和随机数2，看结果是否和xx相等，相等则验证了客户端的身份，并采用协商的算法通过随机数1,2,3得到加密的秘钥k。

​	(7) 服务端采用hash算法计算随机数1,2,3得到zz发送给客户端。

​	(8) 客户端采用同样的hash算法计算随机数1,2,3，看结果是否和zz相等，如果相等则验证了服务端的身份，并采用协商的算法通过随机数1,2,3得到加密秘钥k，至此协商秘钥的过程完成，之后通信采用此加密秘钥k进行加密传输。



有什么常用的加密算法？

​	常见的对称加密算法：AES、DES、3DES

​	常见的非对称加密算法：RSA、DSA、ECC

对称加密和非对称加密发生在什么环节？

​	对称加密发生在**建立连接前**的阶段，非对称加密发生在**建立连接后的通信**阶段。

非对称加密加密的是什么内容？

​	加密的是**通信时的报文**。

为什么要有2种加密方式？

​	首先明确一点：对称加密：安全程度低，效率高。

​							非对称加密：安全，效率低。

​	此时针对连接建立前，未进行数据的传输，选择使用对称加密的算法。

​							通信时，保障数据安全为第一位，选择使用非对称加密的算法。



## **三、HTTP2：**

HTTP2对比HTTP1有什么优化和提升的地方？简述下这些优化点背后的原理

优化：解决了队头阻塞，性能提高，改进传输性能，实现低延时和高吞吐量。

解决了**队头阻塞**的原理：首先了解一下队头阻塞的原理：http1协议中，浏览器客户端同一时间，针对同意域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。那http2协议是怎么解决这个问题的呢？hhtp2利用了**多路复用**的方法：多路复用允许同时通过单一的http2连接发起多重请求-响应消息。



http2性能提高的原理：进行了**二进制分帧**。在二进制分帧层中， HTTP/2 会将所有传输的信息分割为更小的消息和帧（frame）,并对它们采用二进制格式的编码 ，其中 HTTP1.x 的首部信息会被封装到 HEADER frame，而相应的 Request Body 则封装到 DATA frame 里面。HTTP/2 通信都在一个连接上完成，这个连接可以承载任意数量的双向数据流。



## **四、QUIC / HTTP3 ：**



HTTP3对比HTTP2有什么优化和提升的地方？

性能提升，主要是解决了**TCP阻塞问题**。http2协议底层使用的为TCP，TCP 连接中的任何中断（packet loss）会阻塞所有数据流（Head of line blocking）。因为 HTTP/3 基于 UDP 协议，所以如果数据包丢失，只会中断一个数据流，而不会中断所有流。

HTTP3是TCP还是UDP的？与 HTTP2 底层协议有什么区别？

http3传输层是UDP加QUIC，HTTP2传输层为TCP。



## **五、WebSocket**

WebSocket 有什么特点：

WebSocket协议是基于TCP的一种新的网络协议。它实现了浏览器与服务器全双工（full-duplex）通信，即允许服务器主动发送信息给客户端。因此，在WebSocket中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输，客户端和服务器之间的数据交换变得更加简单。



## **六、Vue**

Vue的路由导航守卫的实现原理是什么，有哪几种模式，不同模式对URL的影响是什么？

**导航守卫**就是**路由跳转前、中、后过程中的一些钩子函数**，这个函数能让你操作一些其他的事儿，这就是导航守卫。

Vue的路由实现，**hash模式** 和 **history模式**。

hash模式:在浏览器url#后面的字符称为hash，用window.location.hash读取；

特点：hash虽然在url中，但不被包括在http请求中；仅用来知道浏览器动作，hash不会重新加载页面。

history模式：url没有#号，前端的 URL 被包括在HTTP请求中。

Vue有什么事件通信的方式：

1.通过porps实现父子组件通信

2.通过$emit触发自定义事件，常用语子组件给父组件通信

3.vueX，状态管理

4.EventBus总线通信

5.$parent访问父组件

6.$root访问根组件



## **七、WebWorker / ServiceWorker / WebAsssmembly**

WebWorker的作用是什么，可以用于什么场景？如何通信（监听消息和发送消息）？

​	Web Workers 使得一个 Web 应用程序可以在与主执行线程分离的后台线程中运行一个脚本操作。这样做的好处是可以在一个单独的线程中执行费时的处理任务，从而允许主（通常是UI）线程运行而不被阻塞。

​	使用场景：

​	**加密数据** 有些加解密的算法比较复杂，或者在加解密很多数据的时候，这会非常耗费计算资源，导致UI线程无响应，因此这是使用Web Worker的好时机，使用Worker 线程可以让用户更加无缝的操作 UI。

​	**预取数据** 有时候为了提升数据加载速度，可以提前使用 Worker 线程获取数据，因为Worker线程是可以是用 `XMLHttpRequest` 的。

​	**预渲染** 在某些渲染场景下，比如渲染复杂的 canvas 的时候需要计算的效果比如反射、折射、光影、材料等，这些计算的逻辑可以使用Worker线程来执行，也可以使用多个Worker线程，这里有个射线追踪的示例。

复杂数据处理场景 某些检索、排序、过滤、分析会非常耗费时间，这时可以使用Web Worker来进行，不占用主线程。

​	如何通信：

- `worker.postMessage`: 主线程往worker线程发消息，消息可以是任意类型数据，包括二进制数据
- `worker.onmessage`: 指定worker线程发消息时的回调

ServiceWorker的作用是什么，PWA是什么？

作用：ServiceWorker主要用来做持久的离线缓存。

PWA全称Progressive Web Apps（渐进式WebApp），是通过现代API来构建和增强的，这些API提供了与原生App相似的能力、可靠性、可安装性，而且具备一套代码即可触达任何人、任何地方、任何设备。

WebAssembly的作用是什么，能应用在什么场景里？

WebAssembly（简称为Wasm）。作为一种小型且快速的**二进制格式编程语言**，它可以为Web应用提供接近原生的性能。

应用场景：游戏、音乐流、视频编辑、以及CAD应用等**性能敏感型**的用例中。



# **八、前端安全**

#### XSS是什么，有什么攻击场景，具体如何防范？

​	跨站脚本攻击（也称为XSS）指利用[网站漏洞](https://baike.baidu.com/item/网站漏洞/847280?fromModule=lemma_inlink)从用户那里恶意盗取信息。

​	类型：

​	1、反射型 （Reflected XSS ） 发出请求时，XSS代码出现在url中，作为输入提交到服务器端，服务器端解析后响应，XSS代码随响应内容一起传回给浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，所以叫反射型XSS。

​	2、存储型存 Stored XSS和 Reflected XSS的差别就在于，具有攻击性的脚本被保存到了服务器端（数据库，内存，文件系统）并且可以被普通用户完整的从服务的取得并执行，从而获得了在网络上传播的能力。

​	3、DOM型 （DOM-based or local XSS） 即基于DOM或本地的 XSS 攻击：其实是一种特殊类型的反射型 XSS，它是基于 DOM文档对象模型的一种漏洞。可以通过 DOM来动态修改页面内容，从客户端获取 DOM中的数据并在本地执行。基于这个特性，就可以利用 JS脚本来实现 XSS漏洞的利用。

​	防范：

​		1.**输入过滤**：对所有用户提交内容进行可靠的输入验证，包括对 URL、查询关键字、POST数据等，仅接受指定长度范围内、采用适当格式、采用所预期的字符的内容提交，对其他的一律过滤。(客户端和服务器都要)

​		2.**输出转义**：往 HTML 标签之间插入不可信数据的时候，首先要做的就是对不可信数据进行 HTML Entity 编码 

​		3.**使用 HttpOnly Cookie：**将重要的cookie标记为httponly，这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在js脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。

​		

#### CSP是什么，有什么作用？

​		CSP指的是**内容安全策略**，为了缓解很大一部分潜在的跨站脚本问题，浏览器的扩展程序系统引入了内容安全策略（CSP）的一般概念。这将引入一些相当严格的策略，会使扩展程序在默认情况下更加安全，开发者可以创建并强制应用一些规则，管理网站允许加载的内容。



#### CSRF是什么，有什么攻击场景，具体如何防范？

​		**跨站请求伪造**（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。

​		**场景**：跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。

​		**防范**：

​				**添加校验token**：由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。